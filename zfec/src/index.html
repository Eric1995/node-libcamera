<!doctype html>
<html>
  <head></head>
  <body>
    <h2>Wasm</h2>
    <script type="module">
      // console.log('hello world!');
      // const memory = new WebAssembly.Memory({ initial: 64 });
      const res = await fetch('zfec.wasm');
      const bytes = await res.arrayBuffer();
      const result = await WebAssembly.instantiate(bytes, {
        env: {
          memory: new WebAssembly.Memory({ initial: 64 }),
          // __table_base: 1024,
          // __memory_base: 1024,
          // __indirect_function_table: new WebAssembly.Table({
          //   initial: 0,
          //   maximum: 0,
          //   element: 'anyfunc', // 表示可以存储任何函数类型
          // }),
        },
      });
      const memory = result.instance.exports.memory;
      let ptr = result.instance.exports.malloc(1024 * 1024);
      const HEAPU8 = new Uint8Array(memory.buffer);
      const { fec_init, fec_new, fec_encode, fec_decode, fec_free, get_int_ptr, sum } = result.instance.exports;

      const data = 'abcdefghijklmnopqrstuvwx';
      const ECC_K = 4;
      const ECC_C = 4;
      const BLK_SZ = data.length / ECC_K;
      const src_ptr = ptr;
      const SRC_PTR = new Uint32Array(memory.buffer, ptr, ECC_K);
      ptr += 4 * ECC_K;
      // ------------------------------------------------------------
      const fecs_ptr = ptr;
      const FECS_PTR = new Int32Array(memory.buffer, ptr, ECC_C);
      ptr += 4 * ECC_C;
      // -----------------------------------------------------------------------
      const HEAPU8_SRC = new Uint8Array(memory.buffer, ptr, ECC_K * BLK_SZ);
      for (let i = 0; i < ECC_K; i++) {
        SRC_PTR[i] = ptr + i * BLK_SZ;
      }
      for (let i = 0; i < data.length; i++) {
        HEAPU8_SRC[i] = data.charCodeAt(i);
      }
      ptr += ECC_K * BLK_SZ;
      // --------------------------------------------------------------------
      const HEAPU8_FECS = new Uint8Array(memory.buffer, ptr, ECC_C * BLK_SZ);
      for (let i = 0; i < ECC_C; i++) {
        FECS_PTR[i] = ptr + i * BLK_SZ;
      }
      ptr += ECC_C * BLK_SZ;
      // ----------------------------------------------------------------------
      const HEAPU32_BLOCKS = new Uint32Array(memory.buffer, ptr, ECC_C);
      const blocks_ptr = ptr;
      for (let i = 0; i < ECC_C; i++) {
        HEAPU32_BLOCKS[i] = ECC_K + i;
      }
      ptr += 4 * ECC_C;
      // ----------------------------------------

      fec_init();
      const zfecCodec = fec_new(ECC_K, ECC_K + ECC_C);
      fec_encode(zfecCodec, src_ptr, fecs_ptr, blocks_ptr, ECC_C, BLK_SZ);

      for (let i = 2 * BLK_SZ; i < 4 * BLK_SZ; i++) {
        HEAPU8_SRC[i] = HEAPU8_FECS[i];
      }
      // for (let i = 0; i < ECC_K * BLK_SZ; i++) {
      //   HEAPU8_SRC[i] = 122;
      // }
      HEAPU32_BLOCKS[0] = 0;
      HEAPU32_BLOCKS[1] = 1;
      console.dir(new TextDecoder().decode(HEAPU8_SRC));
      // console.dir(new TextDecoder().decode(HEAPU8_FECS));
      fec_decode(zfecCodec, src_ptr, fecs_ptr, blocks_ptr, BLK_SZ);
      console.dir(new TextDecoder().decode(HEAPU8_FECS));
      console.dir(HEAPU32_BLOCKS.toString());
      fec_free(zfecCodec);
    </script>
  </body>
</html>
